import os
import json
import requests
import zipfile
from bs4 import BeautifulSoup
from datetime import datetime
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import time
import logging

# Diretório de download das extensões
DOWNLOAD_DIR = "exploit_permissions/dump"
os.makedirs(DOWNLOAD_DIR, exist_ok=True)

# Diretório para armazenar os JSONs de cada path
EXTENSIONS_JSON_DIR = os.path.join(DOWNLOAD_DIR, "extensions_json")
os.makedirs(EXTENSIONS_JSON_DIR, exist_ok=True)

# Diretório para logs
LOGS_DIR = os.path.join(DOWNLOAD_DIR, "logs")
os.makedirs(LOGS_DIR, exist_ok=True)

# URL base do Chrome Web Store
BASE_URL = "https://chrome.google.com/webstore/category/extensions"
PATHS = [
    "",
    "/productivity/communication",
    "/productivity/education",
    "/productivity/tools",
    "/productivity/developer",
    "/productivity/workflow",
    "/lifestyle/art",
    "/lifestyle/well_being",
    "/lifestyle/shopping",
    "/lifestyle/entertainment",
    "/lifestyle/household",
    "/lifestyle/games",
    "/lifestyle/news",
    "/lifestyle/fun",
    "/lifestyle/social",
    "/lifestyle/travel",
    "/make_chrome_yours/accessibility",
    "/make_chrome_yours/functionality",
    "/make_chrome_yours/privacy",
]

# Função para configurar o logger
def setup_logger():
    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    log_filename = os.path.join(LOGS_DIR, f"{timestamp}.log")

    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(message)s",
        handlers=[
            logging.FileHandler(log_filename),  # Log em arquivo
            logging.StreamHandler()  # Log no console
        ]
    )
    return logging.getLogger()

# Função para configurar o driver do Selenium
def setup_driver():
    """Configura o driver do Selenium."""
    options = webdriver.ChromeOptions()
    options.add_argument("--headless")  # Execute em modo headless, sem abrir a janela do navegador
    driver = webdriver.Chrome(options=options)
    return driver

# Função para carregar todas as extensões
def load_all_extensions(driver, path, logger):
    """Carrega todas as extensões até que o botão 'Carregar mais' não esteja mais disponível."""
    logger.info(f"Acessando: {path}")
    driver.get(path)  # Acesse a URL específica do caminho
    time.sleep(2)  # Aguarda um pouco para que a página carregue

    while True:
        try:
            # Aguarda até que o botão "Carregar mais" esteja visível usando o novo XPath
            load_more_button = WebDriverWait(driver, 10).until(
                EC.visibility_of_element_located((By.XPATH, "//button[@jsname='t6Kl7b']//span[contains(text(), 'Carregar mais')]"))
            )
            driver.execute_script("arguments[0].click();", load_more_button)
            logger.info("Clicou em 'Carregar mais'")
            time.sleep(2)  # Aguarda um pouco para que novas extensões sejam carregadas
            
            # Conta as tags 'a' que possuem './detail/' no href
            soup = BeautifulSoup(driver.page_source, 'html.parser')
            a_tags = soup.find_all('a', href=True)
            detail_links = [link for link in a_tags if './detail/' in link['href']]
            logger.info(f"Quantidade de extensões carregadas em tela: {len(detail_links)}")

            if len(detail_links) >= 1568:
                break

        except Exception as e:
            logger.error("Não há mais extensões para carregar ou erro ao clicar no botão:", exc_info=True)
            break

# Função para extrair os IDs das extensões
def get_extension_ids(driver, logger):
    """Extrai os IDs das extensões da página atual."""
    soup = BeautifulSoup(driver.page_source, 'html.parser')
    extension_ids = []
    for link in soup.find_all('a', href=True):
        if './detail/' in link['href']:
            extension_id = link['href'].split('/')[-1]
            extension_ids.append(extension_id)
    
    return list(set(extension_ids))

# Função para baixar a extensão
def download_extension(extension_id, logger):
    """Baixa a extensão no formato CRX."""
    logger.info(f"Baixando extensão: {extension_id}")
    url = f"https://clients2.google.com/service/update2/crx?response=redirect&prodversion=91.0&acceptformat=crx2,crx3&x=id%3D{extension_id}%26uc"
    response = requests.get(url, stream=True)
    
    if response.status_code == 200:
        crx_path = os.path.join(DOWNLOAD_DIR, f"{extension_id}.crx")
        with open(crx_path, 'wb') as file:
            file.write(response.content)
        logger.info(f"Extensão {extension_id} baixada com sucesso.")
        return crx_path
    
    logger.error(f"Erro ao baixar a extensão {extension_id}.")
    return None

# Função para extrair o manifest
def extract_manifest(crx_path, logger):
    """Extrai o manifest.json de um arquivo CRX."""
    logger.info(f"Extraindo o manifest do arquivo CRX: {crx_path}")
    
    try:
        with zipfile.ZipFile(crx_path, 'r') as zip_ref:
            for file in zip_ref.namelist():
                if 'manifest.json' in file:
                    with zip_ref.open(file) as manifest_file:
                        return json.load(manifest_file)
                    
    except json.JSONDecodeError as e:
        logger.error(f"Erro ao decodificar o JSON do manifest: {e}")
    except Exception as e:
        logger.error(f"Erro ao extrair o manifest de {crx_path}: {e}")

    return None

# Função para salvar todas as informações das extensões em um único arquivo JSON
def save_all_manifests(manifests, logger):
    """Salva todas as informações das extensões em um único arquivo JSON."""
    logger.info("Salvando informações das extensões em JSON.")
    json_path = os.path.join(DOWNLOAD_DIR, "extensions_info.json")
    
    # Criar o dicionário com as informações
    data_to_save = {
        "extensions_count": len(manifests),
        "extraction_date": datetime.now().isoformat(),
        "extensions": manifests
    }
    
    with open(json_path, 'w', encoding='utf-8') as file:
        json.dump(data_to_save, file, indent=4, ensure_ascii=False)

# Função para salvar os manifestos em JSON por categoria
def save_manifests_by_path(path, manifests, logger):
    """Salva as informações das extensões em um JSON separado por path."""
    category = path.strip("/").replace("/", "_") or "root"
    json_filename = f"extensions_{category}.json"
    json_path = os.path.join(EXTENSIONS_JSON_DIR, json_filename)

    data_to_save = {
        "path": path,
        "extensions_count": len(manifests),
        "extraction_date": datetime.now().isoformat(),
        "extensions": manifests
    }

    with open(json_path, 'w', encoding='utf-8') as file:
        json.dump(data_to_save, file, indent=4, ensure_ascii=False)
    
    logger.info(f"Dados salvos em {json_path}")

# Execução principal do script
if __name__ == "__main__":
    logger = setup_logger()  # Configura o logger
    start_time = datetime.now()  # Marca o início da execução
    driver = setup_driver()

    for path in PATHS:
        full_path = BASE_URL + path
        load_all_extensions(driver, full_path, logger)
        extension_ids = get_extension_ids(driver, logger)
        manifests = []

        for ext_id in extension_ids:
            crx_path = download_extension(ext_id, logger)
            
            if crx_path:
                manifest = extract_manifest(crx_path, logger)
                if manifest:
                    manifests.append({
                        "id": ext_id,
                        "name": manifest.get("name", "unknown_extension"),
                        "permissions": manifest.get("permissions", []),
                        "host_permissions": manifest.get("host_permissions", []),
                        "content_scripts": manifest.get("content_scripts", []),
                        "manifest_version": manifest.get("manifest_version", "unknown")
                    })
                os.remove(crx_path)  

        save_manifests_by_path(path, manifests, logger)  

    driver.quit()  # Fecha o navegador após a execução
    
    end_time = datetime.now()  # Marca o fim da execução
    total_duration = end_time - start_time
    logger.info(f"Tempo total de execução: {str(total_duration).split('.')[0]}")